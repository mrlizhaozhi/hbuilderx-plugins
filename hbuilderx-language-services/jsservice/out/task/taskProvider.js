"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.register=void 0;const jsonc=require("jsonc-parser"),path=require("path"),vscode=require("vscode"),nls=require("vscode-nls"),typescriptService_1=require("../typescriptService"),languageDescription_1=require("../utils/languageDescription"),tsconfig_1=require("../utils/tsconfig"),tsconfigProvider_1=require("./tsconfigProvider"),localize=nls.loadMessageBundle(),exists=async e=>{try{return!!((await vscode.workspace.fs.stat(e)).type&vscode.FileType.File)}catch(e){return!1}};class TscTaskProvider{constructor(e){this.client=e,this.projectInfoRequestTimeout=2e3,this.autoDetect="on",this.disposables=[],this.tsconfigProvider=new tsconfigProvider_1.TsConfigProvider,vscode.workspace.onDidChangeConfiguration(this.onConfigurationChanged,this,this.disposables),this.onConfigurationChanged()}dispose(){this.disposables.forEach((e=>e.dispose()))}async provideTasks(e){const t=vscode.workspace.workspaceFolders;if("off"===this.autoDetect||!t||!t.length)return[];const s=new Set,o=[];for(const t of await this.getAllTsConfigs(e))s.has(t.fsPath)||(s.add(t.fsPath),o.push(...await this.getTasksForProject(t)));return o}async resolveTask(e){const t=e.definition;if(/\\tsconfig.*\.json/.test(t.tsconfig))return void vscode.window.showWarningMessage(localize("badTsConfig",'TypeScript Task in tasks.json contains "\\\\". TypeScript tasks tsconfig must use "/"'));const s=t.tsconfig;if(!s)return;if(void 0===e.scope||e.scope===vscode.TaskScope.Global||e.scope===vscode.TaskScope.Workspace)return;const o=e.scope.uri.with({path:e.scope.uri.path+"/"+s}),i={uri:o,fsPath:o.fsPath,posixPath:o.path,workspaceFolder:e.scope};return this.getTasksForProjectAndDefinition(i,t)}async getAllTsConfigs(e){const t=new Set,s=[...await this.getTsConfigForActiveFile(e),...await this.getTsConfigsInWorkspace()];for(const e of s)await exists(e.uri)&&t.add(e);return Array.from(t)}async getTsConfigForActiveFile(e){const t=vscode.window.activeTextEditor;if(t&&(0,languageDescription_1.isTsConfigFileName)(t.document.fileName)){const e=t.document.uri;return[{uri:e,fsPath:e.fsPath,posixPath:e.path,workspaceFolder:vscode.workspace.getWorkspaceFolder(e)}]}const s=this.getActiveTypeScriptFile();if(!s)return[];const o=await Promise.race([this.client.value.execute("projectInfo",{file:s,needFileNameList:!1},e),new Promise((e=>setTimeout((()=>e(typescriptService_1.ServerResponse.NoContent)),this.projectInfoRequestTimeout)))]);if("response"!==o.type||!o.body)return[];const{configFileName:i}=o.body;if(i&&!(0,tsconfig_1.isImplicitProjectConfigFile)(i)){const e=path.normalize(i),t=vscode.Uri.file(e),s=vscode.workspace.getWorkspaceFolder(t);return[{uri:t,fsPath:e,posixPath:t.path,workspaceFolder:s}]}return[]}async getTsConfigsInWorkspace(){return Array.from(await this.tsconfigProvider.getConfigsForWorkspace())}static async getCommand(e){if(e.workspaceFolder){const t=await TscTaskProvider.getLocalTscAtPath(path.dirname(e.fsPath));if(t)return t;const s=await TscTaskProvider.getLocalTscAtPath(e.workspaceFolder.uri.fsPath);if(s)return s}return"tsc"}static async getLocalTscAtPath(e){const t=process.platform,s=path.join(e,"node_modules",".bin");return"win32"===t&&await exists(vscode.Uri.file(path.join(s,"tsc.cmd")))?path.join(s,"tsc.cmd"):"linux"!==t&&"darwin"!==t||!await exists(vscode.Uri.file(path.join(s,"tsc")))?void 0:path.join(s,"tsc")}getActiveTypeScriptFile(){const e=vscode.window.activeTextEditor;if(e){const t=e.document;if(t&&("typescript"===t.languageId||"typescriptreact"===t.languageId))return this.client.value.toPath(t.uri)}}getBuildTask(e,t,s,o,i){const r=new vscode.Task(i,e||vscode.TaskScope.Workspace,localize("buildTscLabel","build - {0}",t),"tsc",new vscode.ShellExecution(s,o),"$tsc");return r.group=vscode.TaskGroup.Build,r.isBackground=!1,r}getWatchTask(e,t,s,o,i){const r=new vscode.Task(i,e||vscode.TaskScope.Workspace,localize("buildAndWatchTscLabel","watch - {0}",t),"tsc",new vscode.ShellExecution(s,[...o,"--watch"]),"$tsc-watch");return r.group=vscode.TaskGroup.Build,r.isBackground=!0,r}async getTasksForProject(e){const t=await TscTaskProvider.getCommand(e),s=await this.getBuildShellArgs(e),o=this.getLabelForTasks(e),i=[];return"build"!==this.autoDetect&&"on"!==this.autoDetect||i.push(this.getBuildTask(e.workspaceFolder,o,t,s,{type:"typescript",tsconfig:o})),"watch"!==this.autoDetect&&"on"!==this.autoDetect||i.push(this.getWatchTask(e.workspaceFolder,o,t,s,{type:"typescript",tsconfig:o,option:"watch"})),i}async getTasksForProjectAndDefinition(e,t){const s=await TscTaskProvider.getCommand(e),o=await this.getBuildShellArgs(e),i=this.getLabelForTasks(e);let r;return void 0===t.option?r=this.getBuildTask(e.workspaceFolder,i,s,o,t):"watch"===t.option&&(r=this.getWatchTask(e.workspaceFolder,i,s,o,t)),r}async getBuildShellArgs(e){const t=["-p",e.fsPath];try{const t=await vscode.workspace.fs.readFile(e.uri),s=Buffer.from(t).toString("utf-8"),o=jsonc.parse(s);if(null==o?void 0:o.references)return["-b",e.fsPath]}catch(e){}return t}getLabelForTasks(e){if(e.workspaceFolder){const t=vscode.Uri.file(path.normalize(e.workspaceFolder.uri.fsPath));return path.posix.relative(t.path,e.posixPath)}return e.posixPath}onConfigurationChanged(){const e=vscode.workspace.getConfiguration("typescript.tsc").get("autoDetect");this.autoDetect=void 0===e?"on":e}}function register(e){return vscode.tasks.registerTaskProvider("typescript",new TscTaskProvider(e))}exports.register=register;