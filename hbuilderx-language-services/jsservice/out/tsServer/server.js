"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SyntaxRoutingTsServer=exports.GetErrRoutingTsServer=exports.ProcessBasedTsServer=exports.ExectuionTarget=void 0;const vscode=require("vscode"),protocol_const_1=require("../protocol.const"),callbackMap_1=require("../tsServer/callbackMap"),requestQueue_1=require("../tsServer/requestQueue"),serverError_1=require("../tsServer/serverError"),typescriptService_1=require("../typescriptService"),dispose_1=require("../utils/dispose");var ExectuionTarget,RequestState;!function(e){e[e.Semantic=0]="Semantic",e[e.Syntax=1]="Syntax"}(ExectuionTarget=exports.ExectuionTarget||(exports.ExectuionTarget={}));class ProcessBasedTsServer extends dispose_1.Disposable{constructor(e,t,r,s,n,i,o,c){super(),this._serverId=e,this._serverSource=t,this._process=r,this._tsServerLogFile=s,this._requestCanceller=n,this._version=i,this._telemetryReporter=o,this._tracer=c,this._requestQueue=new requestQueue_1.RequestQueue,this._callbacks=new callbackMap_1.CallbackMap,this._pendingResponses=new Set,this._onEvent=this._register(new vscode.EventEmitter),this.onEvent=this._onEvent.event,this._onExit=this._register(new vscode.EventEmitter),this.onExit=this._onExit.event,this._onError=this._register(new vscode.EventEmitter),this.onError=this._onError.event,this._process.onData((e=>{this.dispatchMessage(e)})),this._process.onExit((e=>{this._onExit.fire(e),this._callbacks.destroy("server exited")})),this._process.onError((e=>{this._onError.fire(e),this._callbacks.destroy("server errored")}))}get tsServerLogFile(){return this._tsServerLogFile}write(e){this._process.write(e)}dispose(){super.dispose(),this._callbacks.destroy("server disposed"),this._pendingResponses.clear()}kill(){this._process.kill()}dispatchMessage(e){try{switch(e.type){case"response":this._serverSource?this.dispatchResponse({...e,_serverType:this._serverSource}):this.dispatchResponse(e);break;case"event":const t=e;if("requestCompleted"===t.event){const e=t.body.request_seq,r=this._callbacks.fetch(e);r&&(this._tracer.traceRequestCompleted(this._serverId,"requestCompleted",e,r),r.onSuccess(void 0))}else this._tracer.traceEvent(this._serverId,t),this._onEvent.fire(t);break;default:throw new Error(`Unknown message type ${e.type} received`)}}finally{this.sendNextRequests()}}tryCancelRequest(e,t){try{return this._requestQueue.tryDeletePendingRequest(e)?(this.logTrace(`Canceled request with sequence number ${e}`),!0):!!this._requestCanceller.tryCancelOngoingRequest(e)||(this.logTrace(`Tried to cancel request with sequence number ${e}. But request got already delivered.`),!1)}finally{const r=this.fetchCallback(e);r&&r.onSuccess(new typescriptService_1.ServerResponse.Cancelled(`Cancelled request ${e} - ${t}`))}}dispatchResponse(e){const t=this.fetchCallback(e.request_seq);t&&(this._tracer.traceResponse(this._serverId,e,t),e.success?t.onSuccess(e):"No content available."===e.message?t.onSuccess(typescriptService_1.ServerResponse.NoContent):t.onError(serverError_1.TypeScriptServerError.create(this._serverId,this._version,e)))}executeImpl(e,t,r){const s=this._requestQueue.createRequest(e,t),n={request:s,expectsResponse:r.expectsResult,isAsync:r.isAsync,queueingType:ProcessBasedTsServer.getQueueingType(e,r.lowPriority)};let i;return r.expectsResult&&(i=new Promise(((t,n)=>{this._callbacks.add(s.seq,{onSuccess:t,onError:n,queuingStartTime:Date.now(),isAsync:r.isAsync},r.isAsync),r.token&&r.token.onCancellationRequested((()=>{this.tryCancelRequest(s.seq,e)}))})).catch((e=>{throw e instanceof serverError_1.TypeScriptServerError&&(r.token&&r.token.isCancellationRequested||this._telemetryReporter.logTelemetry("languageServiceErrorResponse",e.telemetry)),e}))),this._requestQueue.enqueue(n),this.sendNextRequests(),i}sendNextRequests(){for(;0===this._pendingResponses.size&&this._requestQueue.length>0;){const e=this._requestQueue.dequeue();e&&this.sendRequest(e)}}sendRequest(e){const t=e.request;this._tracer.traceRequest(this._serverId,t,e.expectsResponse,this._requestQueue.length),e.expectsResponse&&!e.isAsync&&this._pendingResponses.add(e.request.seq);try{this.write(t)}catch(e){const r=this.fetchCallback(t.seq);r&&r.onError(e)}}fetchCallback(e){const t=this._callbacks.fetch(e);if(t)return this._pendingResponses.delete(e),t}logTrace(e){this._tracer.logTrace(this._serverId,e)}static getQueueingType(e,t){return ProcessBasedTsServer.fenceCommands.has(e)?requestQueue_1.RequestQueueingType.Fence:t?requestQueue_1.RequestQueueingType.LowPriority:requestQueue_1.RequestQueueingType.Normal}}exports.ProcessBasedTsServer=ProcessBasedTsServer,ProcessBasedTsServer.fenceCommands=new Set(["change","close","open","updateOpen"]);class RequestRouter{constructor(e,t){this.servers=e,this.delegate=t}execute(e,t,r){if(RequestRouter.sharedCommands.has(e)&&void 0===r.executionTarget){const s=this.servers.map((()=>RequestState.Unresolved));let n,i;if(r.token){const e=new vscode.CancellationTokenSource;r.token.onCancellationRequested((()=>{s.some((e=>e===RequestState.Resolved))||e.cancel()})),n=e.token}for(let o=0;o<this.servers.length;++o){const c=this.servers[o].server.executeImpl(e,t,{...r,token:n});0===o&&(i=c),c&&c.then((t=>{s[o]=RequestState.Resolved;const r=s.find((e=>2===e.type));return r&&this.delegate.onFatalError(e,r.err),t}),(t=>{throw s[o]=new RequestState.Errored(t),s.some((e=>e===RequestState.Resolved))&&this.delegate.onFatalError(e,t),t}))}return i}for(const{canRun:s,server:n}of this.servers)if(!s||s(e,r))return n.executeImpl(e,t,r);throw new Error(`Could not find server for command: '${e}'`)}}RequestRouter.sharedCommands=new Set(["change","close","open","updateOpen","configure","configurePlugin"]);class GetErrRoutingTsServer extends dispose_1.Disposable{constructor(e,t){super(),this._onEvent=this._register(new vscode.EventEmitter),this.onEvent=this._onEvent.event,this._onExit=this._register(new vscode.EventEmitter),this.onExit=this._onExit.event,this._onError=this._register(new vscode.EventEmitter),this.onError=this._onError.event,this.getErrServer=e.getErr,this.mainServer=e.primary,this.router=new RequestRouter([{server:this.getErrServer,canRun:e=>["geterr","geterrForProject"].includes(e)},{server:this.mainServer,canRun:void 0}],t),this._register(this.getErrServer.onEvent((e=>{GetErrRoutingTsServer.diagnosticEvents.has(e.event)&&this._onEvent.fire(e)}))),this._register(this.mainServer.onEvent((e=>{GetErrRoutingTsServer.diagnosticEvents.has(e.event)||this._onEvent.fire(e)}))),this._register(this.getErrServer.onError((e=>this._onError.fire(e)))),this._register(this.mainServer.onError((e=>this._onError.fire(e)))),this._register(this.mainServer.onExit((e=>{this._onExit.fire(e),this.getErrServer.kill()})))}get tsServerLogFile(){return this.mainServer.tsServerLogFile}kill(){this.getErrServer.kill(),this.mainServer.kill()}executeImpl(e,t,r){return this.router.execute(e,t,r)}}exports.GetErrRoutingTsServer=GetErrRoutingTsServer,GetErrRoutingTsServer.diagnosticEvents=new Set([protocol_const_1.EventName.configFileDiag,protocol_const_1.EventName.syntaxDiag,protocol_const_1.EventName.semanticDiag,protocol_const_1.EventName.suggestionDiag]);class SyntaxRoutingTsServer extends dispose_1.Disposable{constructor(e,t,r){super(),this._projectLoading=!0,this._onEvent=this._register(new vscode.EventEmitter),this.onEvent=this._onEvent.event,this._onExit=this._register(new vscode.EventEmitter),this.onExit=this._onExit.event,this._onError=this._register(new vscode.EventEmitter),this.onError=this._onError.event,this.syntaxServer=e.syntax,this.semanticServer=e.semantic,this.router=new RequestRouter([{server:this.syntaxServer,canRun:(e,t)=>{switch(t.executionTarget){case ExectuionTarget.Semantic:return!1;case ExectuionTarget.Syntax:return!0}return!!SyntaxRoutingTsServer.syntaxAlwaysCommands.has(e)||!SyntaxRoutingTsServer.semanticCommands.has(e)&&!!(r&&this.projectLoading&&SyntaxRoutingTsServer.syntaxAllowedCommands.has(e))}},{server:this.semanticServer,canRun:void 0}],t),this._register(this.syntaxServer.onEvent((e=>this._onEvent.fire(e)))),this._register(this.semanticServer.onEvent((e=>{switch(e.event){case protocol_const_1.EventName.projectLoadingStart:this._projectLoading=!0;break;case protocol_const_1.EventName.projectLoadingFinish:case protocol_const_1.EventName.semanticDiag:case protocol_const_1.EventName.syntaxDiag:case protocol_const_1.EventName.suggestionDiag:case protocol_const_1.EventName.configFileDiag:case protocol_const_1.EventName.setTypings:this._projectLoading=!1}return this._onEvent.fire(e)}))),this._register(this.semanticServer.onExit((e=>{this._onExit.fire(e),this.syntaxServer.kill()}))),this._register(this.semanticServer.onError((e=>this._onError.fire(e))))}get projectLoading(){return this._projectLoading}get tsServerLogFile(){return this.semanticServer.tsServerLogFile}kill(){this.syntaxServer.kill(),this.semanticServer.kill()}executeImpl(e,t,r){return this.router.execute(e,t,r)}}exports.SyntaxRoutingTsServer=SyntaxRoutingTsServer,SyntaxRoutingTsServer.syntaxAlwaysCommands=new Set(["navtree","getOutliningSpans","jsxClosingTag","selectionRange","format","formatonkey","docCommentTemplate"]),SyntaxRoutingTsServer.semanticCommands=new Set(["geterr","geterrForProject","projectInfo"]),SyntaxRoutingTsServer.syntaxAllowedCommands=new Set(["completions","completionEntryDetails","completionInfo","definition","definitionAndBoundSpan","documentHighlights","implementation","navto","quickinfo","references","rename","signatureHelp"]),function(e){e.Unresolved={type:0},e.Resolved={type:1};e.Errored=class{constructor(e){this.err=e,this.type=2}}}(RequestState||(RequestState={}));