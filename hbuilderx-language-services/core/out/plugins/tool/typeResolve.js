"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getTokenAtPosition=exports.getRelevantTokens=exports.getTypeName=exports.isInString=exports.getArgumentsSpecialStringType=void 0;const ts=require("typescript/lib/tsserverlibrary");function getArgumentsSpecialStringType(e,n,t){var o;let i=t.languageService.getSignatureHelpItems(e,n,void 0);if(i){let e=i.items;if(e.length>0){let n=e[0],t=i.argumentIndex;if((null==n?void 0:n.parameters)&&(null===(o=null==n?void 0:n.parameters)||void 0===o?void 0:o.length)>t){let e=n.parameters[t],o="";null==e||e.displayParts.forEach((e=>{o+=e.text}));let i=o.split(":");if(2===i.length){return i[1].split("|")}}}}return[]}function getTokenAtPosition(e,n){return getTokenAtPositionWorker(e,n,!0,void 0,!1)}function getTokenAtPositionWorker(e,n,t,o,i){let s=e;e:for(;;){for(const r of s.getChildren(e)){if((t?r.getFullStart():r.getStart(e,!0))>n)break;const l=r.getEnd();if(n<l||n===l&&(r.kind===ts.SyntaxKind.EndOfFileToken||i)){s=r;continue e}if(o&&l===n){const t=findPrecedingToken(n,e,r);if(t&&o(t))return t}}return s}}function isNonWhitespaceToken(e){return ts.isToken(e)}function some(e,n){if(e){if(!n)return e.length>0;for(const t of e)if(n(t))return!0}return!1}function binarySearchKey(e,n,t,o,i){if(!some(e))return-1;let s=i||0,r=e.length-1;for(;s<=r;){const i=s+(r-s>>1);switch(o(t(e[i],i),n)){case-1:s=i+1;break;case 0:return i;case 1:r=i-1}}return~s}function nodeHasTokens(e,n){return e.kind!==ts.SyntaxKind.EndOfFileToken&&0!==e.getWidth(n)}function findRightmostChildNodeWithTokens(e,n,t){for(let o=n-1;o>=0;o--){e[o];if(nodeHasTokens(e[o],t))return e[o]}}function findRightmostToken(e,n){if(isNonWhitespaceToken(e))return e;const t=e.getChildren(n);if(0===t.length)return e;const o=findRightmostChildNodeWithTokens(t,t.length,n);return o&&findRightmostToken(o,n)}function findPrecedingToken(e,n,t,o){const i=function t(i){if(isNonWhitespaceToken(i)&&i.kind!==ts.SyntaxKind.EndOfFileToken)return i;const s=i.getChildren(n),r=binarySearchKey(s,e,((e,n)=>n),((n,t)=>e<s[n].end?!s[n-1]||e>=s[n-1].end?0:1:-1));if(r>=0&&s[r]){const i=s[r];if(e<i.end){const l=i.getStart(n,!o);if(l>=e||!nodeHasTokens(i,n)){const e=findRightmostChildNodeWithTokens(s,r,n);return e&&findRightmostToken(e,n)}return t(i)}}const l=findRightmostChildNodeWithTokens(s,s.length,n);return l&&findRightmostToken(l,n)}(t||n);return i}function getRelevantTokens(e,n){console.log(`getRelevantTokens params: ${e}`);const t=findPrecedingToken(e,n);if(console.log(`previous token pos: ${null==t?void 0:t.pos}`),console.log(`previous token end: ${null==t?void 0:t.end}`),console.log(`previous token kind: ${null==t?void 0:t.kind}`),t&&e<=t.end&&(isMemberName(t)||isKeyword(t.kind))){console.log("getRelevatTokens enter if");const e=findPrecedingToken(t.getFullStart(),n,void 0);return console.log(`context token pos: ${null==e?void 0:e.pos}`),console.log(`context token end: ${null==e?void 0:e.end}`),{contextToken:e,previousToken:t}}return{contextToken:t,previousToken:t}}function isMemberName(e){return e.kind===ts.SyntaxKind.Identifier}function isKeyword(e){return ts.SyntaxKind.FirstKeyword<=e&&e<=ts.SyntaxKind.LastKeyword}function getTouchingPropertyName(e,n){return getTouchingToken(e,n,(e=>isPropertyNameLiteral(e)||isKeyword(e.kind)))}function getTouchingToken(e,n,t){return getTokenAtPositionWorker(e,n,!1,t,!1)}function isPropertyNameLiteral(e){switch(e.kind){case ts.SyntaxKind.Identifier:case ts.SyntaxKind.StringLiteral:case ts.SyntaxKind.NoSubstitutionTemplateLiteral:case ts.SyntaxKind.NumericLiteral:return!0;default:return!1}}function getLeftmostAccessExpression(e){for(;isAccessExpression(e);)e=e.expression;return e}function isAccessExpression(e){return e.kind===ts.SyntaxKind.PropertyAccessExpression||e.kind===ts.SyntaxKind.ElementAccessExpression}function nodeIsMissing(e){return void 0===e||e.pos===e.end&&e.pos>=0&&e.kind!==ts.SyntaxKind.EndOfFileToken}function isCallExpression(e){return e.kind===ts.SyntaxKind.CallExpression}function last(e){return e[e.length-1]}function isLiteralImportTypeNode(e){return ts.isImportTypeNode(e)&&ts.isLiteralTypeNode(e.argument)&&ts.isStringLiteral(e.argument.literal)}function isInRightSideOfInternalImportEqualsDeclaration(e){for(;e.parent.kind===ts.SyntaxKind.QualifiedName;)e=e.parent;return isInternalModuleImportEqualsDeclaration(e.parent)}function isInternalModuleImportEqualsDeclaration(e){return e.kind===ts.SyntaxKind.ImportEqualsDeclaration&&e.moduleReference.kind!==ts.SyntaxKind.ExternalModuleReference}function skipAlias(e,n){return e.flags&ts.SymbolFlags.Alias?n.getAliasedSymbol(e):e}function symbolCanBeReferencedAtTypeLocation(e,n,t=new Map){const o=e;return!!(o.flags&ts.SymbolFlags.Type)||n.isUnknownSymbol(o)||!!(o.flags&ts.SymbolFlags.Module)&&n.getExportsOfModule(o).some((e=>symbolCanBeReferencedAtTypeLocation(e,n,t)))}function isInString(e,n,t=findPrecedingToken(n,e)){if(t&&isStringTextContainingNode(t)){const o=t.getStart(e),i=t.getEnd();if(o<n&&n<i)return!0;if(n===i)return!!t.isUnterminated}return!1}function isStringTextContainingNode(e){return e.kind===ts.SyntaxKind.StringLiteral||isTemplateLiteralKind(e.kind)}function isTemplateLiteralKind(e){return ts.SyntaxKind.FirstTemplateToken<=e&&e<=ts.SyntaxKind.LastTemplateToken}function getTypeName(e,n,t){const o=getRelevantTokens(t,n);o.previousToken;let i=o.contextToken;console.log(`context token start:  ${null==i?void 0:i.pos}`),console.log(`context token end: ${null==i?void 0:i.end}`),console.log(`context token kind:  ${null==i?void 0:i.kind}`);const s=e.getTypeChecker();let r,l=getTokenAtPosition(n,t),a=l,d=!1,c=!1;if(i){let e=i.parent;if(console.log(`parent kind: ${e.kind}`),console.log(`parent pos: ${e.pos}`),console.log(`parent end: ${e.end}`),i.kind===ts.SyntaxKind.DotToken||i.kind===ts.SyntaxKind.QuestionDotToken)switch(console.log("contextToken kind dot"),d=i.kind===ts.SyntaxKind.DotToken,c=i.kind===ts.SyntaxKind.QuestionDotToken,console.log(`parent kind: ${e.kind}`),e.kind){case ts.SyntaxKind.PropertyAccessExpression:console.log(`parent pos: ${e.pos}`),console.log(`parent end: ${e.end}`),r=e,a=r.expression;const t=getLeftmostAccessExpression(r);if(console.log(`node kind: ${a.kind}`),nodeIsMissing(t)||(isCallExpression(a)||ts.isFunctionLike(a))&&a.end===i.pos&&a.getChildCount(n)&&last(a.getChildren(n)).kind!==ts.SyntaxKind.CloseParenToken)return;break;case ts.SyntaxKind.QualifiedName:a=e.left;break;case ts.SyntaxKind.ModuleDeclaration:a=e.name;break;case ts.SyntaxKind.ImportType:a=e;break;case ts.SyntaxKind.MetaProperty:a=e.getFirstToken(n);break;default:return}}let g=!1,u=[];(d||c)&&function(){var e;console.log("get typescript member symbol");const n=isLiteralImportTypeNode(a),t=n&&!a.isTypeOf,o=isInRightSideOfInternalImportEqualsDeclaration(a);if(ts.isEntityName(a)||n||ts.isPropertyAccessExpression(a)){console.log("entity name");const i=ts.isModuleDeclaration(a.parent);i&&(g=!0);let r=s.getSymbolAtLocation(a);if(console.log(`symbol node start: ${a.pos}`),console.log(`symbol node end: ${a.end}`),console.log(`symbol node kind: ${a.kind}`),console.log(`symbol node flags: ${a.flags}`),console.log(`symbol text: ${r.escapedName}`),r){console.log("enter symbol if"),console.log(`symbol flags: ${r.flags}`),console.log(`symbol declarations length: ${r.declarations.length}`);{console.log("enter symbol second if");const l=s.getExportsOfModule(r),d=e=>s.isValidPropertyAccess(n?a:a.parent,e.name),c=e=>symbolCanBeReferencedAtTypeLocation(e,s),g=i?e=>{var n;return!!(e.flags&ts.SymbolFlags.Namespace)&&!(null===(n=e.declarations)||void 0===n?void 0:n.every((e=>e.parent===a.parent)))}:o?e=>c(e)||d(e):t?c:d;for(const e of l)g(e)&&u.push(e);if(
//!isTypeLocation &&
r.declarations&&r.declarations.some((e=>e.kind!==ts.SyntaxKind.SourceFile&&e.kind!==ts.SyntaxKind.ModuleDeclaration&&e.kind!==ts.SyntaxKind.EnumDeclaration))){console.log("enter symbol third if");let n=s.getTypeOfSymbolAtLocation(r,a);n.getSymbol()&&console.log("type is: ",null===(e=n.getSymbol())||void 0===e?void 0:e.escapedName)}}}}}()}exports.getArgumentsSpecialStringType=getArgumentsSpecialStringType,exports.getTokenAtPosition=getTokenAtPosition,exports.getRelevantTokens=getRelevantTokens,exports.isInString=isInString,exports.getTypeName=getTypeName;